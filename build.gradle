/* Documentqzione
    - Come configurare task test sotto del plugin android: https://github.com/kotest/kotest/issues/622

    - test selettivo DA LINEA DI COMANDO: gradle testDebugUnitTest --tests ExampleUnitTest

    - Viene stampato anche una lista dei risultati!!! su html

    - Si devono registrare le task fatte con groovy ( per essere applicate nel progetto di riferimento!!!)
    ls
    - come si costruisce una custom task https://docs.gradle.org/current/userguide/custom_tasks.html

    - tutorial espressioni regolari di groovy: https://e.printstacktrace.blog/groovy-regular-expressions-the-definitive-guide/

    - Vogella tutorial gradle con esercizi: https://www.vogella.com/tutorials/GradleTutorial/article.html
      DEBUG DI GRADLE IN ANDROID STUDIO

    - https://stackoverflow.com/questions/22017433/debugging-gradle-build-files-in-intellij-android-studio

    - https://www.jetbrains.com/help/idea/getting-started-with-groovy.html#test_groovy

    - Project.apply    usato per applicare il plugin al progetto

    - TASK EXEC per inviare comandi (https://stackoverflow.com/questions/35561014/gradle-execute-multiple-commands-from-task)
      Si puo' fare eseguire piu' linee di comando
      documentazione ufficiale: https://docs.gradle.org/current/dsl/org.gradle.api.tasks.Exec.html
      esempio pratico (task exec con DEPENDS ON: https://stackoverflow.com/questions/33759583/how-to-enable-read-write-contacts-permission-when-run-connected-android-test)

    - Oppure emulatore pronto: https://stackoverflow.com/questions/37024316/how-to-control-android-emulator-from-gradle

    - DOCUMENTAZIONE VARIABILI AMBIENTALI IN GITHUB ACTIONS: https://docs.github.com/en/actions/using-workflows/workflow-commands-for-github-actions
      Si possono anche modificare variabili ambientali!!!!

    - Semplice lista di comandi ADB da remoto: https://gist.github.com/hivivo/ee4663565a290253ffc22a4c1eb7b8aa

    - ORDINE DI ESECUZIONE DEI TEST STRUMENTALI!!!!!  https://stackoverflow.com/questions/25308301/test-order-with-espresso

    - INSTRUMENTATIONREGISTRY (to get context e altro): https://developer.android.com/reference/androidx/test/InstrumentationRegistry

    - INSTRUMENTATION TAG in Manifest!!!!!!! https://developer.android.com/guide/topics/manifest/instrumentation-element

    - per il context in Instrumented Test: InstrumentationRegistry.getInstrumentation().targetContext
      https://stackoverflow.com/questions/52924431/androidx-test-instrumentationregistry-is-deprecated

    - Custom Task Runner (per override Runner): https://androidx.de/androidx/test/runner/AndroidJUnitRunner.html

    - XML INSTRUMENTED TEST PLUGIN: https://github.com/schroepf/TestLab/blob/master/android/android-xml-run-listener/README.md!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      DA METTERE DENTRO UNA TASK!!!!!!!!!!!!
 */

/* CODICE con spiegazioni
    Codice per configurazione groovy:

    configurations {
        groovy
    }
    dependencies {
        groovy 'org.apache.groovy:groovy-all:4.0.0'
    }
    task downloadGroovy(type: Copy) {
        from configurations.groovy
        into file('groovy-xml-4.0.0.jar')
    }



 */

// Top-level build file where you can add configuration options common to all sub-projects/modules.
buildscript {
    repositories {
        google()
        mavenCentral()
    }
    dependencies {
        classpath "com.android.tools.build:gradle:7.0.3"
        classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:1.5.20"
        //classpath 'org.codehaus.groovy:groovy-all:4.0.0'

        // NOTE: Do not place your application dependencies here; they belong
        // in the individual module build.gradle files
    }
}

task clean(type: Delete) {
    delete rootProject.buildDir
}

abstract class GreetingTask extends DefaultTask {
    @TaskAction
    def greet() {
        println 'Ciao da Giuseppe!!!'
        println '...anche un altro messaggio...'
        println ' e poi un terzo messaggio'
    }
}

tasks.register('ciao', GreetingTask)

//legge un file in windows e lo stampa in console!!!!!!!!
abstract class Example extends DefaultTask {
    @TaskAction
    def greet() {
        new File("C:/Users/giuse/Documents/Example.txt").eachLine {
            line -> println "line : $line";
        }
    }
}
tasks.register('lettura', Example)

//altro modo di scrivere ed implementare task!!!
class Eccomi implements Plugin<Project> {
    //applica ad un progetto un plugin!!! ma si lancia con il nome del plugin!!!!!!
    void apply(Project project) {
        project.task('ciaoBeppe') {
            doLast {
                println 'ciao da Giuseppe e Gradle'
            }
        }
    }
}
// Apply the plugin
apply plugin: Eccomi

/*tasks.withType(Test) {
    filter {
        //se si mette il seguente esegue solo il primo test (da linea di comando e build!!!)
        includeTestsMatching "ExampleUnitTest.primo_test"
        //fa' tutti i primi test delle due classi (oppure con Regex!!!)
        //includeTestsMatching "*.primo_test"
    }
    testLogging {
        // set options for log level LIFECYCLE
        events TestLogEvent.FAILED,
                TestLogEvent.PASSED,
                TestLogEvent.SKIPPED,
                TestLogEvent.STANDARD_OUT
        exceptionFormat TestExceptionFormat.FULL
        showExceptions true
        showCauses true
        showStackTraces true

        // set options for log level DEBUG and INFO
        debug {
            events TestLogEvent.STARTED,
                    TestLogEvent.FAILED,
                    TestLogEvent.PASSED,
                    TestLogEvent.SKIPPED,
                    TestLogEvent.STANDARD_ERROR,
                    TestLogEvent.STANDARD_OUT
            exceptionFormat TestExceptionFormat.FULL
        }
        info.events = debug.events
        info.exceptionFormat = debug.exceptionFormat

        afterSuite { desc, result ->
            if (!desc.parent) { // will match the outermost suite
                def output = "Results: ${result.resultType} (${result.testCount} tests, ${result.successfulTestCount} successes, ${result.failedTestCount} failures, ${result.skippedTestCount} skipped)"
                def startItem = '|  ', endItem = '  |'
                def repeatLength = startItem.length() + output.length() + endItem.length()
                println('\n' + ('-' * repeatLength) + '\n' + startItem + output + endItem + '\n' + ('-' * repeatLength))
            }
        }
    }
}*/
/*task transformXml {
    ext.srcFile = file('mountains.xml')
    ext.destDir = new File(buildDir, 'generated')
    inputs.file srcFile
    outputs.dir destDir
    doLast {
        println "Transforming source file."
        destDir.mkdirs()
        def mountains = new XmlParser().parse(srcFile)
        mountains.mountain.each { mountain ->
            def name = mountain.name[0].text()
            def height = mountain.height[0].text()
            def destFile = new File(destDir, "${name}.txt")
            destFile.text = "$name -> ${height}\n"
        }
    }
}*/
task launchComands(type:Exec) {
    //workingDir '../tomcat/bin'

    //on windows:
    //commandLine 'cmd', '/c', 'adb devices'
    //commandLine 'cmd', '/c', 'adb shell'

    commandLine 'cmd', '/c', 'adb devices'

    //commandLine 'cmd', '/c', 'adb devices'.execute()

    //commandLine 'cmd', '/c', 'adb devices'

    //on linux
    //commandLine './stop.sh'

    //store the output instead of printing to the console:
    //standardOutput = new ByteArrayOutputStream()

    //extension method stopTomcat.output() can be used to obtain the output:
    //ext.output = {return standardOutput.toString()}
}

task lancia(){
    doLast {
        launchComands()
        //launchComands()
    }
}
task senchaBuild() {
    doLast {
        senchaBuild_steps()
    }
}


task senchaBuild_steps() {
    exec {
        //workingDir 'src/main/app/MYAPP'
        commandLine 'cmd', 'c', 'adb devices'
    }
    /*exec {
        //workingDir 'src/main/app/MYOTHERAPP'
        commandLine 'cmd', 'c', 'adb devices'
    }*/

}


